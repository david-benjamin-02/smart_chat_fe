import React, { useState, useRef, useEffect } from 'react';
import 'bootstrap/dist/css/bootstrap.min.css';
import 'bootstrap-icons/font/bootstrap-icons.css';
// import './App.css';
import LanguageSelector from './components/LanguageSelector';
import FilePicker from './components/FilePicker';
import SearchBar from './components/SearchBar';
import AudioRecorder from './components/AudioRecorder';
import DropDownMenu from './components/DropDownMenu';
import ContactModal from './components/ContactModal';
import SettingsModal from './components/SettingsModal';
import { Socket } from 'socket.io-client';
import VoiceChat from './components/VoiceChat';
import WaveformPlayer from './components/WaveformPlayer';
import axios from 'axios';


export default function ChatApp() {
  const [contacts, setContacts] = useState([]);
  const uidw = localStorage.setItem('uid', '99cd72f6-2448-4b3c-b87d-dc1013772c12');

  const uid = localStorage.getItem('uid');
  const micResetRef = useRef(null);
  const messageEndRef = useRef(null);
  const [selectedContact, setSelectedContact] = useState(null);
  // const [messages, setMessages] = useState(initialMessages);
  const [messages, setMessages] = useState({});
  const [selectedCon, setSelectedCon] = useState(null);

  // const handleSendVoiceMessage = (blob) => {
  //   const url = URL.createObjectURL(blob);
  //   console.log(url);

  //   setMessages(prev => ({
  //     ...prev,
  //     [selectedCon]: [...(prev[selectedCon] || []), { type: 'audio', url }]
  //   }));
  // };
  // const handleSendVoiceMessage = (blob) => {
  //   const audioUrl = URL.createObjectURL(blob);

  //   const newMessage = {
  //     id: Date.now(),
  //     type: 'audio',
  //     sender: 'me',
  //     audioUrl,
  //     timestamp: new Date(),
  //   };

  //   setMessages(prev => [...prev, newMessage]);

  //   // send to socket / receiver if needed
  // };

  const recordingSentRef = useRef(false);
  const [input, setInput] = useState('');
  const chunksRef = useRef([]);
  const [searchTerm, setSearchTerm] = useState('');
  const [showContactModal, setShowContactModal] = useState(false);
  const [selectedAttachment, setSelectedAttachment] = useState(null);
  const [messageType, setMessageType] = useState(null);
  const [showSettings, setShowSettings] = useState(false);
  const [pendingLangConfirm, setPendingLangConfirm] = useState(false);
  const [showTranslateIcons, setShowTranslateIcons] = useState(false);
  const [isLanguageActive, setIsLanguageActive] = useState(false);
  const [currentLangCode, setCurrentLangCode] = useState('en');
  const [isTranslating, setIsTranslating] = useState(false);
  const clearLangHighlightRef = useRef(null);
  const [isTranscribing, setIsTranscribing] = useState(false);
  const [shouldTranslate, setShouldTranslate] = useState(false);
  const [isMicActive, setIsMicActive] = useState(false); // mic state passed from AudioRecorder
  // default false
  const [settings, setSettings] = useState({
    sendingLang: 'English',
    receivingLang: 'English',
    chatFormat: 'Text Mode',
  });
  const [isVoiceChatActive, setIsVoiceChatActive] = useState(false);
  const [isAudioRecorderActive, setIsAudioRecorderActive] = useState(false);
  const [isVoiceChatRecording, setIsVoiceChatRecording] = useState(false);
  const [elapsed, setElapsed] = useState(0);
  const timerRef = useRef(null);
  const canvasRef = useRef(null);
  const audioContextRef = useRef(null);
  const streamRef = useRef(null);
  const mediaRecorderRef = useRef(null);
  const analyserRef = useRef(null);
  const animationRef = useRef(null);
  const formatTime = (sec) => {
    const m = String(Math.floor(sec / 60)).padStart(2, '0');
    const s = String(sec % 60).padStart(2, '0');
    return `${m}:${s}`;
  };

  const startVoiceRecording = async () => {
    if (isVoiceChatRecording) return;

    try {
      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
      streamRef.current = stream;
      chunksRef.current = [];

      const mediaRecorder = new MediaRecorder(stream);
      mediaRecorderRef.current = mediaRecorder;

      recordingSentRef.current = false;

      mediaRecorder.ondataavailable = (e) => {
        if (e.data.size > 0) {
          chunksRef.current.push(e.data);
        }
      };

      mediaRecorder.onstop = () => {
        console.log('in')
        if (recordingSentRef.current) {
          console.log("Already sent, skipping...");
          return;
        }

        recordingSentRef.current = true;

        const blob = new Blob(chunksRef.current, { type: 'audio/webm' });
        handleSendVoiceMessage(blob);
        cleanupRecording();
      };

      mediaRecorder.start();

      const audioContext = new (window.AudioContext || window.webkitAudioContext)();
      const analyser = audioContext.createAnalyser();
      analyser.fftSize = 2048;
      const source = audioContext.createMediaStreamSource(stream);
      source.connect(analyser);

      analyserRef.current = analyser;
      audioContextRef.current = audioContext;

      setIsVoiceChatRecording(true);
      timerRef.current = setInterval(() => setElapsed((prev) => prev + 1), 1000);
      // drawWaveform();
    } catch (err) {
      console.error("Microphone access error:", err);
    }
  };
  useEffect(() => {
    if (isVoiceChatRecording) {
      console.log("Starting waveform animation");
      drawWaveform();
    }
  }, [isVoiceChatRecording]);


  const stopVoiceRecording = () => {
    if (
      mediaRecorderRef.current &&
      mediaRecorderRef.current.state === 'recording'
    ) {
      mediaRecorderRef.current.stop(); // triggers onstop
    }
  };



  const cleanupRecording = () => {
    console.log("oj")
    clearInterval(timerRef.current);
    setElapsed(0);
    cancelAnimationFrame(animationRef.current);
    audioContextRef.current?.close();
    streamRef.current?.getTracks().forEach((track) => track.stop());

    setIsVoiceChatRecording(false);
    recordingSentRef.current = false;
  };



  const drawWaveform = () => {
    const canvas = canvasRef.current;
    const ctx = canvas?.getContext('2d');
    const analyser = analyserRef.current;

    if (!canvas || !ctx || !analyser) {
      console.warn("Canvas or analyser not ready");
      return;
    }

    analyser.fftSize = 2048;
    const bufferLength = analyser.fftSize;
    const dataArray = new Uint8Array(bufferLength);

    const draw = () => {
      animationRef.current = requestAnimationFrame(draw); // ðŸŸ¢ Recursive animation call
      analyser.getByteTimeDomainData(dataArray);

      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.lineWidth = 2;
      ctx.strokeStyle = '#0d6efd';
      ctx.beginPath();

      const sliceWidth = canvas.width / bufferLength;
      let x = 0;

      for (let i = 0; i < bufferLength; i++) {
        const v = dataArray[i] / 128.0;
        const y = (v * canvas.height) / 2;
        i === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
        x += sliceWidth;
      }

      ctx.lineTo(canvas.width, canvas.height / 2);
      ctx.stroke();
    };

    draw(); // ðŸ” Start loop
  };



  const handleTranslate = async () => {
    if (!input.trim()) return;
    setIsTranslating(true);

    try {
      const response = await fetch("http://localhost:8000/translate", {
        method: "POST",
        body: new FormData(Object.entries({
          text: input,
          language: currentLangCode
        }).reduce((form, [k, v]) => {
          form.append(k, v);
          return form;
        }, new FormData())),
      });

      const data = await response.json();
      setInput(data.translated_text || '');
      setPendingLangConfirm(false);
      setShowTranslateIcons(false);
      if (clearLangHighlightRef.current) clearLangHighlightRef.current();
    } catch (error) {
      console.error("Translation failed:", error);
    } finally {
      setIsTranslating(false);
    }
  };


  // useEffect(() => {
  //   if (messageEndRef.current) {
  //     messageEndRef.current.scrollIntoView({ behavior: 'smooth' });
  //   }
  // }, [selectedContact ? messages[selectedContact?.id] : []]);

  useEffect(() => {
    const handleKeyDown = (e) => {
      if (e.key === "Escape") {
        setSelectedContact(null);
        setInput('');
        setShowTranslateIcons(false);
        setSelectedAttachment(null);
        if (clearLangHighlightRef.current) clearLangHighlightRef.current();
        if (micResetRef.current) micResetRef.current();
      }
    };

    window.addEventListener("keydown", handleKeyDown);
    return () => window.removeEventListener("keydown", handleKeyDown);
  }, []);
  useEffect(() => {
    const fetchContacts = async () => {
      try {
        const res = await axios.get(`http://localhost:8000/get-user-contacts/${uid}`);
        setContacts(res.data.contacts);
      } catch (error) {
        console.error("Failed to fetch contacts", error);
      }
    };

    fetchContacts();
  }, []);

  useEffect(() => {
    if (selectedContact && messageEndRef.current) {
      messageEndRef.current.scrollIntoView({ behavior: 'smooth' });
    }
  }, [selectedContact, messages]);


  const handleCancelTranslate = () => {
    setShowTranslateIcons(false);
    setPendingLangConfirm(false); // âœ… clear the block
    // if (clearLangHighlightRef.current) clearLangHighlightRef.current(); // unhighlight the icon
  };

  const handleSettingsSave = (updatedSettings) => {
    setSettings(updatedSettings);
    console.log('Updated Settings:', updatedSettings);
  };
  const handleAddContact = (newContact) => {
    const newId = Math.max(...contacts.map(c => c.id)) + 1;
    const updated = [...contacts, { ...newContact, id: newId, lastMessage: '' }];
    setContacts(updated);
  };
  const handleEditContact = (id, updatedName) => {
    setContacts(contacts.map(contact =>
      contact.id === id ? { ...contact, name: updatedName } : contact
    ));
  };
  const handleDeleteContact = (id) => {
    setContacts(contacts.filter(contact => contact.id !== id));
    if (selectedContact?.id === id && contacts.length > 1) {
      setSelectedContact(contacts.find(c => c.id !== id));
    }
  };

  const sendMessage = () => {
    if ((!input.trim() && !selectedAttachment) || !selectedContact) return;

    const now = new Date();
    const time = now.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });

    let newMessage;
    if (selectedAttachment) {
      const fileURL = URL.createObjectURL(selectedAttachment);
      const type = selectedAttachment.type;
      const name = selectedAttachment.name;

      if (type.startsWith('image/')) {
        newMessage = {
          text: <img src={fileURL} alt="img" className="img-fluid rounded" />,
          sender: 'me',
          messageType: 'Photo',
          time
        };
      } else if (type.startsWith('audio/')) {
        newMessage = {
          text: <audio controls src={fileURL} />,
          sender: 'me',
          messageType: 'Audio',
          time
        };
      } else {
        newMessage = {
          text: (
            <div>
              <i className="bi bi-file-earmark-text me-2" />
              <a href={fileURL} download={name}>{name}</a>
            </div>
          ),
          sender: 'me',
          messageType: 'Document',
          time
        };
      }
    } else {
      newMessage = {
        text: input,
        sender: 'me',
        messageType: 'Text',
        time
      };
    }

    setMessages(prev => ({
      ...prev,
      [selectedContact?.uid]: [...(prev[selectedContact?.uid] || []), newMessage],
    }));

    setContacts(prev =>
      prev.map(c =>
        c.uid === selectedContact?.uid
          ? {
            ...c,
            recent_messages: [
              {
                message_text: newMessage.text || "[Voice Message]",
                sender_id: uid,
                time: newMessage.time,
                message_type: newMessage.messageType || 'Text',
              }
            ],
          }
          : c
      )
    );


    setInput('');
    setSelectedAttachment(null);
    setMessageType(null);
    setShowTranslateIcons(false);
    if (clearLangHighlightRef.current) clearLangHighlightRef.current();
  };


  const handleSendVoiceMessage = (blob) => {
    console.log("heloo")
    const audioUrl = URL.createObjectURL(blob);
    const newMessage = {
      // text: <audio controls src={audioUrl} />,
      text: "",
      sender: 'me',
      type: 'audio',
      audioUrl,
      time: new Date().toLocaleTimeString([], {
        hour: '2-digit',
        minute: '2-digit',
      }),
    };

    setMessages((prev) => (
      {
        ...prev,
        [selectedContact?.id]: [...(prev[selectedContact?.id] || []), newMessage],
      }));
    setContacts(prev =>
      prev.map(c =>
        c.uid === selectedContact?.uid
          ? {
            ...c,
            recent_messages: [
              {
                message_text: newMessage.text || "[Voice Message]",
                sender_id: uid,
                time: newMessage.time,
                message_type: newMessage.messageType || 'Text',
              }
            ]

          }
          : c
      )
    );
  };


  return (

    <div className="container-fluid vh-100 d-flex flex-column">
      <div className="row flex-grow-1">
        {/* Sidebar */}
        <div className="col-4 border-end bg-light d-flex flex-column p-0" style={{ height: '100vh' }}>
          <div className="d-flex justify-content-between align-items-center p-3 border-bottom">
            <h4 className="mb-0">Chats</h4>
            <DropDownMenu
              onOpenContact={() => setShowContactModal(true)}
              onOpenSettings={() => setShowSettings(true)}
            />
            <ContactModal
              show={showContactModal}
              onClose={() => setShowContactModal(false)}
              onAddContact={handleAddContact}
              onEditContact={handleEditContact}
              onDeleteContact={handleDeleteContact}
              contacts={contacts}
            />
            <SettingsModal
              show={showSettings}
              onClose={() => setShowSettings(false)}
              settings={settings}
              onSave={handleSettingsSave}
            />
          </div>

          <div className="px-3">
            <SearchBar searchTerm={searchTerm} setSearchTerm={setSearchTerm} />
          </div>

          <div className="flex-grow-1 overflow-auto custom-scrollbar"
          // style={{
          //   scrollbarWidth: 'none',            // Firefox
          //   msOverflowStyle: 'none',           // Internet Explorer and Edge
          // }}
          >
            {/* <style>{`
              div::-webkit-scrollbar {
                display: none;
              }
  `}</style> */}
            {contacts
              .filter((contact) =>
                contact.name.toLowerCase().includes(searchTerm.toLowerCase())
              )
              .map((contact) => (
                <div
                  key={contact.uid}
                  className={`p-3 cursor-pointer ${selectedContact?.uid === contact.uid ? 'bg-secondary text-white' : 'bg-light'}`}
                  onClick={() => {
                    setSelectedContact(contact);
                    setMessages({
                      [contact.uid]: contact.recent_messages.map(msg => ({
                        text: msg.message_text,
                        sender_id: msg.sender_id,
                        time: msg.time,
                        type: msg.message_type?.toLowerCase() === 'audio' ? 'audio' : 'text',
                        audioUrl: msg.message_type?.toLowerCase() === 'audio' ? null : undefined,
                      }))
                    });

                    setInput('');
                    setShowTranslateIcons(false);
                    setCurrentLangCode('en');
                    if (clearLangHighlightRef.current) clearLangHighlightRef.current();
                    if (micResetRef.current) micResetRef.current();
                  }}

                >
                  <strong>{contact.name}</strong>
                  <div className="d-flex justify-content-between text-muted small">
                    <span>
                      {contact.recent_messages?.length > 0 ? (
                        contact.recent_messages[0].sender_id === uid
                          ? `You: ${contact.recent_messages[0].message_text}`
                          : `${contact.name}: ${contact.recent_messages[0].message_text}`
                      ) : (
                        <i>No messages yet</i>
                      )}
                    </span>
                    <span>
                      {contact.recent_messages?.[0]?.time}
                    </span>
                  </div>

                </div>
              ))}
          </div>
        </div>

        {/* Chat Window */}
        <div className="col-8 d-flex flex-column" style={{ height: '100vh' }}>
          {selectedContact ? (
            <>
              {/* Chat Header */}
              <div className="p-3 border-bottom bg-white">
                <h5 className="mb-0">{selectedContact.name}</h5>
              </div>

              {/* Scrollable Messages */}
              <div className="flex-grow-1 overflow-auto p-3 bg-light">
                <div className="no-scrollbar">
                  {selectedContact && messages[selectedContact?.uid]?.map((msg, idx) => {
                    const isCurrentUser = msg.sender_id === uid;
                    console.log("msgh", msg)
                    console.log("isCurrentUser", isCurrentUser)
                    console.log("selectedContact", selectedContact)
                    return (
                      <div key={idx} className={`d-flex mb-2 ${isCurrentUser ? 'justify-content-end' : 'justify-content-start'}`}>
                        <div
                          className={`p-2 rounded ${isCurrentUser ? 'bg-success text-white' : 'bg-white border'}`}
                          style={{ maxWidth: '70%' }}
                        >
                          {msg.type === 'audio' ? (
                            msg.audioUrl ? <WaveformPlayer audioUrl={msg.audioUrl} /> : <i>[Audio message]</i>
                          ) : (
                            <span>{msg.text}</span>
                          )}
                          <div className="text-white-50 text-end" style={{ fontSize: '0.65rem', marginTop: '4px' }}>
                            {msg.time}
                          </div>
                        </div>
                      </div>
                    );
                  })}

                  {/* {messages.map((msg, index) => (
                    <div
                      key={index}
                      className={`message ${msg.sender === 'me' ? 'sent' : 'received'}`}
                    >
                      {msg.type === 'audio' ? (
                        <audio controls src={msg.audioUrl} />
                      ) : (
                        <span>{msg.text}</span>
                      )}
                    </div>
                  ))} */}

                  <div ref={messageEndRef} />
                </div>
              </div>

              {/* Input Area */}
              <div className="p-3 border-top bg-white d-flex flex-column">




                {selectedAttachment && (
                  <div className="attachment-preview d-flex align-items-center justify-content-between p-2 mb-2 rounded border bg-light w-100">
                    <div className="d-flex align-items-center">
                      <i className="bi bi-file-earmark-text me-2 text-primary" style={{ fontSize: '1.5rem' }}></i>
                      <div className="text-truncate" style={{ maxWidth: '200px' }}>
                        <strong>{selectedAttachment.name}</strong>
                        <div className="text-muted small">{messageType}</div>
                      </div>
                    </div>
                    <i
                      className="bi bi-x-circle text-danger"
                      style={{ cursor: 'pointer', fontSize: '1.2rem' }}
                      onClick={() => {
                        setSelectedAttachment(null);
                        setMessageType(null);
                      }}
                    ></i>
                  </div>
                )}

                {/* Message input row */}
                <div className="d-flex align-items-end w-100">
                  <FilePicker
                    disabled={!!selectedAttachment}
                    onFileSelect={(file) => {
                      setSelectedAttachment(file);
                      setInput('');
                      if (file.type.startsWith('image/')) setMessageType('Photo');
                      else if (file.type.startsWith('audio/')) setMessageType('Audio');
                      else setMessageType('Document');
                    }}
                  />

                  {isVoiceChatRecording ? (
                    <div className="form-control me-2 d-flex align-items-center bg-light" style={{ height: '60px' }}>
                      {/* <canvas ref={canvasRef} width="150" height="30" style={{ backgroundColor: '#f0f0f0', borderRadius: '4px' }} /> */}
                      <canvas
                        ref={canvasRef}
                        width="300"
                        height="50"
                        style={{
                          backgroundColor: '#f0f0f0',
                          borderRadius: '8px',
                          display: 'block'
                        }}
                      />



                      <span className="ms-3">{formatTime(elapsed)}</span>
                    </div>
                  ) : (
                    <textarea
                      className="form-control me-2"
                      rows="1"
                      value={input}
                      onChange={(e) => setInput(e.target.value)}
                      onKeyDown={(e) => {
                        if (e.key === 'Enter' && !e.shiftKey) {
                          e.preventDefault();
                          sendMessage();
                        }
                      }}
                      placeholder="Type a message..."
                      disabled={!!selectedAttachment || isTranslating || isVoiceChatActive}
                      style={{
                        resize: 'none',
                        overflow: 'hidden',
                        whiteSpace: 'pre-wrap',
                      }}
                    ></textarea>
                  )}



                  {/* onSendVoiceMessage={(blob) => {
                    const audioUrl = URL.createObjectURL(blob);
                    const newMessage = {
                      text: <audio controls src={audioUrl} />,
                      sender: 'me',
                      type: 'audio',
                      audioUrl,
                      time: new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })
                    };
                    const updated = [...(messages[selectedContact?.id] || []), newMessage];
                    setMessages(prev => ({ ...prev, [selectedContact?.id]: updated }));
                  }} */}

                  {showTranslateIcons && !isTranslating && (
                    <div className="d-flex align-items-center me-2">
                      <i
                        className={`bi bi-check-circle me-1 ${input.trim() ? 'text-success' : 'text-secondary'}`}
                        style={{
                          cursor: input.trim() ? 'pointer' : 'not-allowed',
                          opacity: input.trim() ? 1 : 0.5
                        }}
                        onClick={() => {
                          if (input.trim()) handleTranslate(); // Prevent clicking when input is empty
                          (setPendingLangConfirm)(false); // âœ… Confirm language
                        }}
                      ></i>
                      <i
                        className="bi bi-x-circle text-danger"
                        style={{ cursor: 'pointer' }}
                        onClick={() => {
                          setShowTranslateIcons(false);
                          setPendingLangConfirm(false); // âœ… Confirm language
                          if (clearLangHighlightRef.current) clearLangHighlightRef.current();
                        }}
                      ></i>
                    </div>
                  )}

                  {/* <LanguageSelector onHighlightChange={(highlighted) => setShowTranslateIcons(highlighted)} /> */}


                  <LanguageSelector
                    currentLang={currentLangCode}
                    onLangChange={setCurrentLangCode}
                    clearHighlight={(fn) => (clearLangHighlightRef.current = fn)}
                    onHighlightChange={(highlighted) => setShowTranslateIcons(highlighted)}
                    onPendingConfirmChange={setPendingLangConfirm} // âœ… pass this
                    disabled={isMicActive || !!selectedAttachment}
                  />

                  <AudioRecorder
                    onSendAudio={(audioURL) => {
                      const newMessage = {
                        text: <audio controls src={audioURL} />,
                        sender: 'me',
                      };
                      const updated = [...(selectedContact ? messages[selectedContact?.uid] : [] || []), newMessage];
                      setMessages(prev => ({ ...prev, [selectedContact?.id]: updated }));
                      setMessageType('Audio'); // âœ… set audio message type
                    }}
                    onTranscription={(text) => {
                      setInput(text);
                    }}
                    setResetRef={(fn) => (micResetRef.current = fn)}
                    onRecordingStatusChange={setIsMicActive}
                    setIsTranscribing={setIsTranslating}
                    disabled={isVoiceChatRecording || isLanguageActive || isTranslating || pendingLangConfirm || !!selectedAttachment}
                  />

                  {isTranslating || isTranscribing ? (
                    <button className="btn btn-secondary" disabled>
                      <span className="spinner-border spinner-border-sm"></span>
                    </button>
                  ) : input.trim() ? (
                    <button
                      className="btn btn-success"
                      onClick={sendMessage}
                      disabled={isTranslating || isMicActive || pendingLangConfirm}
                    >
                      <i className="bi bi-send"></i>
                    </button>
                  ) : (
                    <VoiceChat
                      isRecording={isVoiceChatRecording}
                      startRecording={startVoiceRecording}
                      stopRecording={stopVoiceRecording}
                    />


                  )}


                </div>
              </div>
            </>
          ) : (
            <div className="d-flex flex-column justify-content-center align-items-center h-100 text-center p-5 bg-light">
              <img src="/logo1.png" alt="Welcome" className="mb-4" style={{ maxWidth: '300px' }} />
              <h4>Welcome to ChatApp</h4>
              <p className="text-muted">Select a chat to start messaging</p>
            </div>
          )}
        </div>
      </div>
    </div>
  );
}